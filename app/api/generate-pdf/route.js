import { NextResponse } from 'next/server'
import { jsPDF } from 'jspdf'
import { db } from '../../../lib/db'
import jwt from 'jsonwebtoken'

export async function POST(request) {
  try {
    const { calculationId, reportType = 'standard' } = await request.json()
    
    // Get user from auth token
    const authHeader = request.headers.get('authorization')
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const token = authHeader.substring(7)
    const decoded = jwt.verify(token, process.env.JWT_SECRET)
    const user = await db.getUserById(decoded.userId)
    
    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 })
    }

    // Get calculation data
    const calculation = await db.getCalculationById(calculationId, user.id)
    if (!calculation) {
      return NextResponse.json({ error: 'Calculation not found' }, { status: 404 })
    }

    // Create PDF
    const pdf = new jsPDF()
    const companyData = calculation.company_data
    const results = calculation.results

    // PDF Header
    pdf.setFontSize(20)
    pdf.setFont('helvetica', 'bold')
    pdf.text('Carbon Footprint Report', 20, 30)
    
    pdf.setFontSize(12)
    pdf.setFont('helvetica', 'normal')
    pdf.text(`Generated: ${new Date().toLocaleDateString('nl-NL')}`, 20, 40)
    pdf.text(`Company: ${companyData.companyName}`, 20, 50)
    pdf.text(`Industry: ${companyData.industry}`, 20, 60)
    pdf.text(`Employees: ${companyData.employees}`, 20, 70)

    // Results Section
    pdf.setFontSize(16)
    pdf.setFont('helvetica', 'bold')
    pdf.text('Carbon Footprint Results', 20, 90)

    pdf.setFontSize(12)
    pdf.setFont('helvetica', 'normal')
    
    let yPos = 110
    pdf.text(`Total CO2 Emissions: ${results.emissions?.total || 0} ton per year`, 20, yPos)
    yPos += 10

    // Breakdown
    pdf.setFont('helvetica', 'bold')
    pdf.text('Breakdown by Category:', 20, yPos + 10)
    yPos += 20
    
    pdf.setFont('helvetica', 'normal')
    if (results.emissions?.breakdown) {
      Object.entries(results.emissions.breakdown).forEach(([category, value]) => {
        pdf.text(`${category}: ${value} ton (${((value/(results.emissions.total || 1))*100).toFixed(1)}%)`, 30, yPos)
        yPos += 10
      })
    }

    // Recommendations
    if (results.recommendations && results.recommendations.length > 0) {
      yPos += 10
      pdf.setFont('helvetica', 'bold')
      pdf.text('Recommendations:', 20, yPos)
      yPos += 10
      
      pdf.setFont('helvetica', 'normal')
      results.recommendations.slice(0, 5).forEach((rec, index) => {
        const text = `${index + 1}. ${rec.action} - Save ${rec.savings} ton CO2`
        const lines = pdf.splitTextToSize(text, 170)
        pdf.text(lines, 30, yPos)
        yPos += lines.length * 7
      })
    }

    // Cost Savings
    if (results.costSavings) {
      yPos += 10
      pdf.setFont('helvetica', 'bold')
      pdf.text('Cost Savings Potential:', 20, yPos)
      yPos += 10
      
      pdf.setFont('helvetica', 'normal')
      pdf.text(`Total Savings: €${results.costSavings.total?.toLocaleString() || 0}`, 30, yPos)
      pdf.text(`Carbon Tax Savings: €${results.costSavings.carbon?.toLocaleString() || 0}`, 30, yPos + 10)
      pdf.text(`Energy Savings: €${results.costSavings.energy?.toLocaleString() || 0}`, 30, yPos + 20)
    }

    // Footer
    pdf.setFontSize(10)
    pdf.setFont('helvetica', 'italic')
    pdf.text('Generated by Carbon Comply - carboncomply.nl', 20, 280)

    // Generate PDF as base64 string (no file storage needed)
    const pdfBase64 = pdf.output('datauristring')
    const pdfBuffer = Buffer.from(pdfBase64.split(',')[1], 'base64')
    
    // Create filename
    const fileName = `carbon-report-${user.companyName?.replace(/[^a-zA-Z0-9]/g, '-')}-${Date.now()}.pdf`

    // Save report record to database (without file path since we're returning directly)
    const reportRecord = await db.saveReport(user.id, calculationId, fileName, 'direct-download')

    // Return PDF directly as download
    return new NextResponse(pdfBuffer, {
      status: 200,
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="${fileName}"`,
        'Content-Length': pdfBuffer.length.toString(),
      },
    })

  } catch (error) {
    console.error('PDF generation error:', error)
    return NextResponse.json(
      { error: `Failed to generate PDF: ${error.message}` },
      { status: 500 }
    )
  }
}
